

void InvertedIndex::startInvertedIndexing(const int desiredNumberOfThreads)
{
    //Контейнер результатов потоков
    std::list<std::future<void>> futures;

    //Запустить потоки
    for (std::size_t docID{}; docID < documents.size(); ++docID)
    {
        //Запустить поток для определения слова (выделения) в документе
        futures.push_back(std::async(&InvertedIndex::defineWord, this, docID, std::cref(documents[docID])));
    }

    try
    {
        //Ожидать завершения потоков
        for (auto &future: futures)
            future.wait();
    }
    //Обработать все исключения, выброшенные в потоках
    catch (const std::exception& e)
    {
        throw;
    }
}

void InvertedIndex::startInvertedIndexing(const int desiredNumberOfThreads)
{
    //Timer test
    Timer t;


    //Количество дополнительных потоков
    //Если количество документов меньше либо равно желаемого количества потоков - использовать количество потоков равным количеству документов.
    //В противном случае - использовать желаемое количество потоков.
    int numberOfThreads = documents.size() <= desiredNumberOfThreads ? documents.size() : desiredNumberOfThreads;

    //Определить количество документов обрабатываемое одним потокам
    std::size_t difference{documents.size() / numberOfThreads};

    //Если количество документов делится с остатком
    if (documents.size() % numberOfThreads)
    {
        //Увеличить количество потоков
        ++numberOfThreads;
    }

    //Контейнер результатов потоков
    std::list<std::future<std::map<std::string, std::vector<Entry>>>> futures(numberOfThreads);

    //ID первого документа для каждого потока
    std::size_t beginDocID{};

    //Для каждого будущего потока
    for (auto &future : futures)
    {
        //ID последнего документа для каждого потока
        std::size_t endDocID{beginDocID + difference - 1};

        //Если ID последнего документа для потока превышает ID документа всех документов
        if (endDocID >= documents.size())
        {
            //Установить ID последнего документа для потока равным ID последнего документа всех документов
            endDocID = documents.size() - 1;
        }

        //std::cout << "beginDocID: " << beginDocID << ", endDocID: " << endDocID << '\n';

        //Запустить чтение файлов в отдельном потоке в своём диапазоне
        future = std::async([this, beginDocID = beginDocID, endDocID = endDocID]()
                            {
                                //База инвертированных индексов для каждого потока
                                std::map<std::string, std::vector<Entry>> invertedIndexesForThread;

                                //Для каждого документа
                                for (std::size_t currentDocID{beginDocID}; currentDocID <= endDocID; ++currentDocID)
                                {
                                    //Определить слово (выделить) в документе
                                    defineWord(currentDocID, documents[currentDocID], invertedIndexesForThread);
                                }

                                //Вернуть базу инвертированных индексов для каждого потока
                                return invertedIndexesForThread;
                            }
        );

        //Определить ID первого документа для следующего потока
        beginDocID = endDocID + 1;
    }

    try
    {
        //Ожидать завершения потоков
        for (auto &future: futures)
        {
            //InvertedIndex::invertedIndexesForThread = future.get();

            for (auto &elem : future.get())
            {
                //Найти слово в базе инвертированных индексов
                auto positionWord{invertedIndexes.find(elem.first)};

                //Слово в базе инвертированных индексов не существует
                if (positionWord == invertedIndexes.end())
                {
                    //Добавить слово c контейнером структур инвертированного индекса в базу инвертированных индексов
                    invertedIndexes.insert({std::move(elem.first), std::move(elem.second)});
                }
                else
                    //Слово в базе инвертированных индексов существует
                {
                    for (auto &entry : elem.second)
                    {
                        //Добавить структуру инвертированного индекса для нового ID документа по слову
                        invertedIndexes[elem.first].push_back(entry);
                    }
                }
            }
        }
    }
    //Обработать все исключения, выброшенные в потоках
    catch (const std::exception& e)
    {
        throw;
    }

    //std::cout << '\n' << "numberOfThreads: " << numberOfThreads << '\n';
    std::cout << '\n' << t.elapsed() << '\n';//*/

    /*
    for (std::size_t docID{}; docID < documents.size(); ++docID)
    {

        defineWord(docID, documents[docID], invertedIndexes);
    }

    std::cout << '\n' << t.elapsed() << '\n';//*/
}

void mergeInvertedIndexBases(std::vector<std::future<std::map<std::basic_string<char>, std::vector<Entry>>>> &futures)
{
    int i{};

    for (int idx{}; idx < futures.size() && futures.size() != 1; idx += 2, ++i)
    {

        //std::cout << futures.size() << " " << idx << " " << i;
        //std::cout << "qqq";
        if ((idx + 1) < futures.size())
        {

            std::map<std::basic_string<char>, std::vector<Entry>> firstInvertedIndexes{std::move(futures[idx]).get()};
            std::map<std::basic_string<char>, std::vector<Entry>> secondInvertedIndexes{std::move(futures[idx + 1]).get()};

            futures[i] = std::async([&futures, idx = idx, firstInvertedIndexes = std::move(firstInvertedIndexes), secondInvertedIndexes = std::move(secondInvertedIndexes)]() mutable
                                    {


                                        for (auto &elem: secondInvertedIndexes)
                                        {
                                            //Найти слово в базе инвертированных индексов
                                            auto positionWord{firstInvertedIndexes.find(elem.first)};

                                            //Слово в базе инвертированных индексов не существует
                                            if (positionWord == firstInvertedIndexes.end())
                                            {
                                                //Добавить слово c контейнером структур инвертированного индекса в базу инвертированных индексов
                                                firstInvertedIndexes.insert(
                                                        {elem.first, std::move(elem.second)});
                                            } else
                                                //Слово в базе инвертированных индексов существует
                                            {
                                                for (auto &entry: elem.second)
                                                {
                                                    //Добавить структуру инвертированного индекса для нового ID документа по слову
                                                    firstInvertedIndexes[elem.first].push_back(entry);
                                                }
                                            }
                                        }

                                        return std::move(firstInvertedIndexes);
                                    }

            );
            //std::cout << "eee";
        }
        else
        {
            //std::cout << "www";
            futures[i] = std::move(futures[idx]);
        }

    }

    //std::cout << "rrr";
    futures.resize(i);

    if (i > 1)
    {
        mergeInvertedIndexBases(futures);
    }

    //return futures[0].get();
}